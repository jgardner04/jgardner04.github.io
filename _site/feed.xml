<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beyond the Corner Office</title>
    <description>Technology musings from Beyond the Corner Office. A Jonathan Gardner blog where all things cloud are discussed.
</description>
    <link>http://0.0.0.0:4000/</link>
    <atom:link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 03 Jul 2017 15:23:25 +0000</pubDate>
    <lastBuildDate>Mon, 03 Jul 2017 15:23:25 +0000</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>Advanced Azure ARM Template</title>
        <description>&lt;span class=&quot;image featured&quot;&gt;&lt;img src=&quot;//btco.azureedge.net/gallery-1600/AdobeStock_61327476-1600.jpeg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;

As you have seen, I have been doing quite a bit of work with ARM templates and VMs recently.  This post is no different.  I have been working on a project where multiple VMs need to be created from a custom image and they need to be joined to an existing domain.  In this post I will walk through the elements of the ARM template I created. **NOTE: This template is not based on any best practices, simply a proof of concept**

Tl;dr - Grab the template from my [GitHub account](//github.com/jgardner04/ARM-Templates/tree/master/domainJoinedCustomImage).

## Creating Multiple Resources
The power of ARM templates is the ability to create complex environments from a single definition file.  Part of that power comes in the ability to create multiple resources of the same type.  This happens through the use of the copy tag when defining a resource.


{% highlight json %}

copy:{ &quot;name&quot;: &quot;storagecopy&quot;, &quot;count&quot;: &quot;[parameters('count')]&quot; }

{% endhighlight %}
&lt;br /&gt;
Access to the current iteration can be done through the use of the copyIndex() function.  This provides the flexibility append it to names creating a unique name for each iteration.  An example of this can be seen in the &quot;name&quot;: example below.

{% highlight json %}
&quot;name&quot;: &quot;[concat(variables('storageAccountName'),copyIndex())]&quot;
{% endhighlight %}
&lt;br /&gt;
## Virtual Machines from a Custom Image

Before we dive into the template it is important to note, at time of writing this, the virtual machine custom image must be in the same storage account as the .vhd that will be deployed with the new Virtual Machines.  It is for this reason that this template creates a &quot;Transfer VM&quot; with a custom script extension.  This script uses PowerShell and [AZCopy](//docs.microsoft.com/en-us/azure/storage/storage-use-azcopy) to move the image from one storage account to the target storage account.  The gold image can be removed after the VMs are deployed without any issue.  The Transfer VM can also be removed.  This could also be scripted but is not included in the current version of the template.  If you want to take a deeper look at creating a VM in this transfer model you can check out the quick start template on [GitHub](//github.com/Azure/azure-quickstart-templates/tree/master/201-vm-custom-image-new-storage-account).

## Networking
This template also assumes that you already have a virtual network created and takes these as parameters to deploy the new virtual machines to this network.  The public IP addresses and NICs will all be attached to this network.  If you have different network requirements, you will need to make these changes before deployment.  In my demo environment, my domain controller is on the same vnet that the virtual machines will be deployed to.  Because of this, I have set my domain controllers to be the DNS servers and set up external forwarders there.  This ensures that the domain join request are routed to the domain controllers.  In other words, standard networking rules apply as if you were doing this on-prem.

## Domain join
The domain join function is performed by a new extension.  Previously it needed to be done through DSC.  I find this to be much smoother.  More information about the extension can be found here on [GitHub](//github.com/Azure/azure-quickstart-templates/tree/master/201-vm-domain-join).

## The Business
Now, down to the code.  I know that is what everyone cares to see anyway.  If you want to download directly or make changes/comments, please do so through [GitHub](//github.com/jgardner04/ARM-Templates).

{% highlight json %}
    {
      &quot;$schema&quot;: &quot;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#&quot;,
      &quot;contentVersion&quot;: &quot;1.0.0.0&quot;,
      &quot;parameters&quot;: {
          &quot;storageAccountName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Prefix name of the storage account to be created&quot;
              }
          },
          &quot;vmCopies&quot;: {
              &quot;type&quot;: &quot;int&quot;,
              &quot;defaultValue&quot;: 1,
              &quot;metadata&quot;: {
                  &quot;descritpion&quot;: &quot;Number of storage accounts to create&quot;
              }
          },
          &quot;storageAccountType&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;defaultValue&quot;: &quot;Standard_LRS&quot;,
              &quot;allowedValues&quot;: [&quot;Standard_LRS&quot;, &quot;Standard_GRS&quot;, &quot;Standard_ZRS&quot;, &quot;Premium_LRS&quot;],
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Storage Account type&quot;
              }
          },
          &quot;vmName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name prefix for the VMs&quot;
              }
          },
          &quot;adminUserName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Admin username for the virtual machines&quot;
              }
          },
          &quot;adminPassword&quot;: {
              &quot;type&quot;: &quot;securestring&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Admin password for virtual machines&quot;
              }
          },
          &quot;dnsLabelPrefix&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;DNS Name Prefix for Public IP&quot;
              }
          },
          &quot;windowsOSVersion&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;defaultValue&quot;: &quot;2012-R2-Datacenter&quot;,
              &quot;allowedValues&quot;: [&quot;2008-R2-SP1&quot;, &quot;2012-Datacenter&quot;, &quot;2012-R2-Datacenter&quot;],
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;The Windows version for the VMs. Allowed values: 2008-R2-SP1, 2012-Datacenter, 2012-R2-Datacenter.&quot;
              }
          },
          &quot;domainToJoin&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;The FQDN of the AD domain&quot;
              }
          },
          &quot;domainUsername&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Username of the account on the domain&quot;
              }

          },
          &quot;ouPath&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;defaultValue&quot;: &quot;&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Specifies an organizational unit (OU) for the domain account. Enter the full distinguished name of the OU in quotation marks. Example: 'OU=testOU; DC=domain; DC=Domain; DC=com&quot;
              }
          },
          &quot;domainJoinOptions&quot;: {
              &quot;type&quot;: &quot;int&quot;,
              &quot;defaultValue&quot;: 3,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Set of bit flags that define the join options. Default value of 3 is a combination of NETSETUP_JOIN_DOMAIN (0x00000001) &amp; NETSETUP_ACCT_CREATE (0x00000002) i.e. will join the domain and create the account on the domain. For more information see https://msdn.microsoft.com/en-us/library/aa392154(v=vs.85).aspx&quot;
              }
          },
          &quot;existingVirtualNetworkName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of the existing VNET&quot;
              }
          },
          &quot;subnetName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of the existing VNET&quot;
              }
          },
          &quot;existingVirtualNetworkResourceGroup&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of the existing VNET Resource Group&quot;
              }
          },
          &quot;transferVmName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;defaultValue&quot;: &quot;TransferVM&quot;,
              &quot;minLength&quot;: 3,
              &quot;maxLength&quot;: 15,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of the Windows VM that will perform the copy of the VHD from a source storage account to the new storage account created in the new deployment, this is known as transfer vm.&quot;
              }
          },
          &quot;customImageStorageContainer&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of storace container for gold image&quot;
              }
          },
          &quot;customImageName&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Name of the VHD to be used as source syspreped/generalized image to deploy the VM. E.g. mybaseimage.vhd.&quot;
              }
          },
          &quot;sourceImageURI&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Full URIs for one or more custom images (VHDs) that should be copied to the deployment storage account to spin up new VMs from them. URLs must be comma separated.&quot;
              }
          },
          &quot;sourceStorageAccountResourceGroup&quot;: {
              &quot;type&quot;: &quot;string&quot;,
              &quot;metadata&quot;: {
                  &quot;description&quot;: &quot;Resource group name of the source storage account.&quot;
              }
          }
      },
      &quot;variables&quot;: {
          &quot;storageAccountName&quot;: &quot;[parameters('storageAccountName')]&quot;,
          &quot;imagePublisher&quot;: &quot;MicrosoftWindowsServer&quot;,
          &quot;imageOffer&quot;: &quot;WindowsServer&quot;,
          &quot;OSDiskName&quot;: &quot;osdiskforwindows&quot;,
          &quot;nicName&quot;: &quot;[parameters('vmName')]&quot;,
          &quot;addressPrefix&quot;: &quot;10.0.0.0/16&quot;,
          &quot;subnetName&quot;: &quot;Subnet&quot;,
          &quot;subnetPrefix&quot;: &quot;10.0.0.0/24&quot;,
          &quot;publicIPAddressName&quot;: &quot;[parameters('vmName')]&quot;,
          &quot;publicIPAddressType&quot;: &quot;Dynamic&quot;,
          &quot;vmStorageAccountContainerName&quot;: &quot;vhds&quot;,
          &quot;vmSize&quot;: &quot;Standard_D1&quot;,
          &quot;windowsOSVersion&quot;: &quot;2012-R2-Datacenter&quot;,
          &quot;virtualNetworkName&quot;: &quot;myVNET&quot;,
          &quot;vnetID&quot;: &quot;[resourceId(parameters('existingVirtualNetworkResourceGroup'), 'Microsoft.Network/virtualNetworks', parameters('existingVirtualNetworkName'))]&quot;,
          &quot;subnetRef&quot;: &quot;[concat(variables('vnetID'),'/subnets/', parameters('subnetName'))]&quot;,
          &quot;customScriptFolder&quot;: &quot;CustomScripts&quot;,
          &quot;trfCustomScriptFiles&quot;: [&quot;ImageTransfer.ps1&quot;],
          &quot;sourceStorageAccountName&quot;: &quot;[substring(split(parameters('sourceImageURI'),'.')[0],8)]&quot;
      },
      &quot;resources&quot;: [{
              &quot;name&quot;: &quot;[concat(variables('storageAccountName'),copyIndex())]&quot;,
              &quot;copy&quot;: {
                  &quot;count&quot;: &quot;[parameters('vmCopies')]&quot;,
                  &quot;name&quot;: &quot;storagecopy&quot;
              },
              &quot;type&quot;: &quot;Microsoft.Storage/storageAccounts&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;sku&quot;: {
                  &quot;name&quot;: &quot;[parameters('storageAccountType')]&quot;
              },
              &quot;apiVersion&quot;: &quot;2016-01-01&quot;,
              &quot;kind&quot;: &quot;Storage&quot;,
              &quot;properties&quot;: {}
          }, {
              &quot;name&quot;: &quot;[concat(variables('publicIPAddressName'),copyIndex())]&quot;,
              &quot;dependsOn&quot;: [&quot;storagecopy&quot;],
              &quot;apiVersion&quot;: &quot;2016-03-30&quot;,
              &quot;copy&quot;: {
                  &quot;count&quot;: &quot;[parameters('vmCopies')]&quot;,
                  &quot;name&quot;: &quot;publicipcopy&quot;
              },
              &quot;type&quot;: &quot;Microsoft.Network/publicIPAddresses&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;properties&quot;: {
                  &quot;publicIPAllocationMethod&quot;: &quot;[variables('publicIPAddressType')]&quot;,
                  &quot;dnsSettings&quot;: {
                      &quot;domainNameLabel&quot;: &quot;[concat(parameters('dnsLabelPrefix'),copyIndex())]&quot;
                  }
              }
          }, {
              &quot;name&quot;: &quot;[parameters('transferVmName')]&quot;,
              &quot;dependsOn&quot;: [&quot;storagecopy&quot;],
              &quot;apiVersion&quot;: &quot;2016-03-30&quot;,
              &quot;type&quot;: &quot;Microsoft.Network/publicIPAddresses&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;properties&quot;: {
                  &quot;publicIPAllocationMethod&quot;: &quot;[variables('publicIPAddressType')]&quot;,
                  &quot;dnsSettings&quot;: {
                      &quot;domainNameLabel&quot;: &quot;[concat(parameters('dnsLabelPrefix'),'trans1')]&quot;
                  }
              }
          }, {
              &quot;apiVersion&quot;: &quot;2016-03-30&quot;,
              &quot;copy&quot;: {
                  &quot;count&quot;: &quot;[parameters('vmCopies')]&quot;,
                  &quot;name&quot;: &quot;niccopies&quot;
              },
              &quot;type&quot;: &quot;Microsoft.Network/networkInterfaces&quot;,
              &quot;name&quot;: &quot;[concat(variables('nicName'),copyIndex())]&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;dependsOn&quot;: [&quot;[concat('Microsoft.Network/publicIPAddresses/',variables('publicIPAddressName'),copyIndex())]&quot;],
              &quot;properties&quot;: {
                  &quot;ipConfigurations&quot;: [{
                      &quot;name&quot;: &quot;ipconfig1&quot;,
                      &quot;properties&quot;: {
                          &quot;privateIPAllocationMethod&quot;: &quot;Dynamic&quot;,
                          &quot;publicIPAddress&quot;: {
                              &quot;id&quot;: &quot;[resourceId('Microsoft.Network/publicIPAddresses',concat(variables('publicIPAddressName'),copyIndex()))]&quot;
                          },
                          &quot;subnet&quot;: {
                              &quot;id&quot;: &quot;[variables('subnetRef')]&quot;
                          }
                      }
                  }]
              }
          }, {
              &quot;apiVersion&quot;: &quot;2016-03-30&quot;,
              &quot;type&quot;: &quot;Microsoft.Network/networkInterfaces&quot;,
              &quot;name&quot;: &quot;[parameters('transferVmName')]&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;dependsOn&quot;: [&quot;[concat('Microsoft.Network/publicIPAddresses/',parameters('transferVmName'))]&quot;],
              &quot;properties&quot;: {
                  &quot;ipConfigurations&quot;: [{
                      &quot;name&quot;: &quot;ipconfig1&quot;,
                      &quot;properties&quot;: {
                          &quot;privateIPAllocationMethod&quot;: &quot;Dynamic&quot;,
                          &quot;publicIPAddress&quot;: {
                              &quot;id&quot;: &quot;[resourceId('Microsoft.Network/publicIPAddresses',parameters('transferVmName'))]&quot;
                          },
                          &quot;subnet&quot;: {
                              &quot;id&quot;: &quot;[variables('subnetRef')]&quot;
                          }
                      }
                  }]
              }
          },

          {
              &quot;comments&quot;: &quot;# TRANSFER VM&quot;,
              &quot;name&quot;: &quot;[parameters('transferVmName')]&quot;,
              &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines&quot;,
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;apiVersion&quot;: &quot;2015-06-15&quot;,
              &quot;dependsOn&quot;: [&quot;storagecopy&quot;, &quot;[concat('Microsoft.Network/networkInterfaces/', parameters('transferVmName'))]&quot;],
              &quot;properties&quot;: {
                  &quot;hardwareProfile&quot;: {
                      &quot;vmSize&quot;: &quot;[variables('vmSize')]&quot;
                  },
                  &quot;osProfile&quot;: {
                      &quot;computerName&quot;: &quot;[parameters('transferVmName')]&quot;,
                      &quot;adminUsername&quot;: &quot;[parameters('AdminUsername')]&quot;,
                      &quot;adminPassword&quot;: &quot;[parameters('adminPassword')]&quot;
                  },
                  &quot;storageProfile&quot;: {
                      &quot;imageReference&quot;: {
                          &quot;publisher&quot;: &quot;[variables('imagePublisher')]&quot;,
                          &quot;offer&quot;: &quot;[variables('imageOffer')]&quot;,
                          &quot;sku&quot;: &quot;[parameters('windowsOSVersion')]&quot;,
                          &quot;version&quot;: &quot;latest&quot;
                      },
                      &quot;osDisk&quot;: {
                          &quot;name&quot;: &quot;[parameters('transferVmName')]&quot;,
                          &quot;vhd&quot;: {
                              &quot;uri&quot;: &quot;[concat('http://', variables('storageAccountName')[0], '.blob.core.windows.net/', variables('vmStorageAccountContainerName'), '/',parameters('transferVmName'),'.vhd')]&quot;
                          },
                          &quot;caching&quot;: &quot;ReadWrite&quot;,
                          &quot;createOption&quot;: &quot;FromImage&quot;
                      }
                  },
                  &quot;networkProfile&quot;: {
                      &quot;networkInterfaces&quot;: [{
                          &quot;id&quot;: &quot;[resourceId('Microsoft.Network/networkInterfaces', parameters('transferVmName'))]&quot;
                      }]
                  }
              },
              &quot;resources&quot;: [{
                  &quot;comments&quot;: &quot;Custom Script that copies VHDs from source storage account to destination storage account&quot;,
                  &quot;apiVersion&quot;: &quot;2015-06-15&quot;,
                  &quot;type&quot;: &quot;extensions&quot;,
                  &quot;name&quot;: &quot;[concat(parameters('transferVmName'),'CustomScriptExtension')]&quot;,
                  &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
                  &quot;dependsOn&quot;: [&quot;[concat('Microsoft.Compute/virtualMachines/', parameters('transferVmName'))]&quot;],
                  &quot;properties&quot;: {
                      &quot;publisher&quot;: &quot;Microsoft.Compute&quot;,
                      &quot;type&quot;: &quot;CustomScriptExtension&quot;,
                      &quot;autoUpgradeMinorVersion&quot;: true,
                      &quot;typeHandlerVersion&quot;: &quot;1.4&quot;,
                      &quot;settings&quot;: {
                          &quot;fileUris&quot;: [&quot;https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/201-vm-custom-image-new-storage-account/ImageTransfer.ps1&quot;]
                      },
                      &quot;protectedSettings&quot;: {
                          &quot;commandToExecute&quot;: &quot;[concat('powershell -ExecutionPolicy Unrestricted -File ','ImageTransfer.ps1 -SourceImage ',parameters('sourceImageURI'),' -SourceSAKey ', listKeys(resourceId(parameters('sourceStorageAccountResourceGroup'),'Microsoft.Storage/storageAccounts', variables('sourceStorageAccountName')), '2015-06-15').key1, ' -DestinationURI https://', variables('StorageAccountName'), '.blob.core.windows.net/vhds', ' -DestinationSAKey ', listKeys(concat('Microsoft.Storage/storageAccounts/', variables('StorageAccountName')), '2015-06-15').key1)]&quot;
                      }
                  }
              }]
          },

          {
              &quot;apiVersion&quot;: &quot;2015-06-15&quot;,
              &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines&quot;,
              &quot;name&quot;: &quot;[concat(parameters('vmName'),copyIndex())]&quot;,
              &quot;copy&quot;: {
                  &quot;count&quot;: &quot;[parameters('vmCopies')]&quot;,
                  &quot;name&quot;: &quot;vmcopies&quot;
              },
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;dependsOn&quot;: [&quot;[concat('Microsoft.Storage/storageAccounts/', variables('storageAccountName'),copyIndex())]&quot;, &quot;[concat('Microsoft.Network/networkInterfaces/', variables('nicName'),copyIndex())]&quot;, &quot;[concat('Microsoft.Compute/virtualMachines/', parameters('transferVmName'),'/extensions/',parameters('transferVmName'),'CustomScriptExtension')]&quot;],
              &quot;properties&quot;: {
                  &quot;hardwareProfile&quot;: {
                      &quot;vmSize&quot;: &quot;[variables('vmSize')]&quot;
                  },
                  &quot;osProfile&quot;: {
                      &quot;computerName&quot;: &quot;[concat(parameters('vmName'),copyIndex())]&quot;,
                      &quot;adminUsername&quot;: &quot;[parameters('adminUsername')]&quot;,
                      &quot;adminPassword&quot;: &quot;[parameters('adminPassword')]&quot;
                  },
                  &quot;storageProfile&quot;: {
                      &quot;osDisk&quot;: {
                          &quot;name&quot;: &quot;[concat(parameters('vmName'),copyIndex(),'-osdisk')]&quot;,
                          &quot;osType&quot;: &quot;windows&quot;,
                          &quot;createOption&quot;: &quot;FromImage&quot;,
                          &quot;caching&quot;: &quot;ReadWrite&quot;,
                          &quot;image&quot;: {
                              &quot;uri&quot;: &quot;[concat('http://', variables('StorageAccountName'), copyIndex(), '.blob.core.windows.net/',variables('vmStorageAccountContainerName'),'/Microsoft.Compute/Images/',parameters('customImageStorageContainer'),'/',parameters('customImageName'))]&quot;
                          },
                          &quot;vhd&quot;: {
                              &quot;uri&quot;: &quot;[concat('http://', variables('StorageAccountName'), copyIndex(), '.blob.core.windows.net/',variables('vmStorageAccountContainerName'),'/',parameters('vmName'),copyIndex(),'-osdisk.vhd')]&quot;
                          }
                      }
                  },
                  &quot;networkProfile&quot;: {
                      &quot;networkInterfaces&quot;: [{
                          &quot;id&quot;: &quot;[resourceId('Microsoft.Network/networkInterfaces',concat(variables('nicName'),copyIndex()))]&quot;
                      }]
                  },
                  &quot;diagnosticsProfile&quot;: {
                      &quot;bootDiagnostics&quot;: {
                          &quot;enabled&quot;: &quot;true&quot;,
                          &quot;storageUri&quot;: &quot;[concat('http://',variables('storageAccountName'),'.blob.core.windows.net')]&quot;
                      }
                  }
              }
          }, {
              &quot;apiVersion&quot;: &quot;2015-06-15&quot;,
              &quot;type&quot;: &quot;Microsoft.Compute/virtualMachines/extensions&quot;,
              &quot;name&quot;: &quot;[concat(parameters('vmName'),copyIndex(),'/joindomain')]&quot;,
              &quot;copy&quot;: {
                  &quot;count&quot;: &quot;[parameters('vmCopies')]&quot;,
                  &quot;name&quot;: &quot;domainextension&quot;
              },
              &quot;location&quot;: &quot;[resourceGroup().location]&quot;,
              &quot;dependsOn&quot;: [&quot;[concat('Microsoft.Compute/virtualMachines/', parameters('vmName'),copyIndex())]&quot;],
              &quot;properties&quot;: {
                  &quot;publisher&quot;: &quot;Microsoft.Compute&quot;,
                  &quot;type&quot;: &quot;JsonADDomainExtension&quot;,
                  &quot;typeHandlerVersion&quot;: &quot;1.3&quot;,
                  &quot;autoUpgradeMinorVersion&quot;: true,
                  &quot;settings&quot;: {
                      &quot;Name&quot;: &quot;[parameters('domainToJoin')]&quot;,
                      &quot;OUPath&quot;: &quot;[parameters('ouPath')]&quot;,
                      &quot;User&quot;: &quot;[concat(parameters('domainToJoin'), '\\', parameters('adminUserName'))]&quot;,
                      &quot;Restart&quot;: &quot;true&quot;,
                      &quot;Options&quot;: &quot;[parameters('domainJoinOptions')]&quot;
                  },
                  &quot;protectedsettings&quot;: {
                      &quot;Password&quot;: &quot;[parameters('adminPassword')]&quot;
                  }
              }
          }
      ]
    }
{% endhighlight %}

Are you using Azure Resource Manager Templates?  If so, we would love to hear about how you are using them in the comments below.  If you like this content and want to know how I work with Microsoft Partners, please check out the [US Partner Community Blog](//blogs.technet.microsoft.com/msuspartner/category/azure-partners/) for some of my other posts.  Don't forget to follow me on [Twitter](//twitter.com/jgardner04).
</description>
        <pubDate>Fri, 22 Jul 2016 16:00:00 +0000</pubDate>
        <link>http://0.0.0.0:4000/azure/2016/07/22/Advanced-VM-ARM-Template.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/azure/2016/07/22/Advanced-VM-ARM-Template.html</guid>
        
        <category>azure</category>
        
        <category>automation</category>
        
        <category>arm</category>
        
        <category>virtual machines</category>
        
        
        <category>Azure</category>
        
      </item>
    
      <item>
        <title>Azure Resource Manager Template Custom Script Extensions</title>
        <description>&lt;span class=&quot;image featured&quot;&gt;&lt;img src=&quot;//btco.azureedge.net/gallery-1600/AdobeStock_99956429-1600.jpeg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;

In my previous article, Building Azure Resource Manager Templates , I covered how to get started with Azure Resource Manager templates.  While they are certainly great for basic deployments, where they really shine is in their ability to allow for complex deployments.  This post will cover the Custom Script Extension and how they can be used to configure Virtual Machines during the deployment process. ***Note: This article makes the assumption that you are familiar with the Azure portal and Visual Studio.  I am not writing a full step-by-step article.  While I will outline all of the things that need to happen, I am not doing a “click here” walk-through.***

# The Setup
When I was working on my ARM Template to deploy [SQL Server 2016 with the AdventureWorks sample databases installed](https://github.com/jgardner04/ARM-Templates/tree/master/Sql2016Ctp3Demo), I needed a way to configure the virtual machine once it was installed.  This is done using the Custom Script for Windows Extension.  It is dependent upon the creation of the virtual machine, as can be seen from the image below and requires that the virtual machine be created before adding the extension.

![Custom Script Extension](//btco.azureedge.net/gallery-800/customscriptextension-800.png)

# The Business
After adding the Custom Script Extension, a resource is added to the virtual machine in the ARM template with they type &quot;extensions&quot;.  The code can be seen below.  It shows up as nested in the JSON Outline window.  It also creates a customScripts folder in the solution.  In the case of a Windows extension this file is a PowerShell or .ps1 file.

{% highlight json %}

    {
      name: test,
      type: extensions,
      location: [resourceGroup().location],
      apiVersion: 2015-06-15,
      dependsOn: [
        [concat('Microsoft.Compute/virtualMachines/', parameters('Sql2016Ctp3DemoName'))] ],
      tags:
        {
          displayName: test
        },
      properties:
        {
          publisher: Microsoft.Compute,
          type: CustomScriptExtension,
          typeHandlerVersion: 1.4,
          autoUpgradeMinorVersion: true,
          settings: {
            fileUris: [ [concat(parameters('_artifactsLocation'), '/', variables('testScriptFilePath'), parameters('_artifactsLocationSasToken'))] ],
            commandToExecute: [concat('powershell -ExecutionPolicy Unrestricted -File ', variables('testScriptFilePath'))]
            }
        }
      }

{% endhighlight %}

From the custom script, I can perform a host of different actions based on PowerShell.  The code below performs a number of actions.  It creates a folder structure, downloads files, creates and executes a PowerShell function to extract the zip files, moves files, executes T-SQL, and opens firewall ports.

{% highlight powershell %}

    # DeploySqlAw2016.ps1 #
    # Parameters

    # Variables
    $targetDirectory = &quot;C:\SQL2016Demo&quot; $adventrueWorks2016DownloadLocation = &quot;https://sql2016demoaddeploy.blob.core.windows.net/adventureworks2016/AdventureWorks2016CTP3.zip&quot;

    # Create Folder Structure
    if(!(Test-Path -Path $targetDirectory)){ New-Item `
      -ItemType Directory `
      -Force `
      -Path $targetDirectory } `
      if(!(Test-Path `
        -Path $targetDirectory\adventureWorks2016CTP3)){ New-Item `
          -ItemType Directory `
          -Force -Path $targetDirectory\adventureWorks2016CTP3 }
    # Download the SQL Server 2016 CTP 3.3 AdventureWorks database files.
    Set-Location $targetDirectory Invoke-WebRequest `
      -Uri $adventrueWorks2016DownloadLocation `
      -OutFile $targetDirectory\AdventureWorks2016CTP3.zip

    # Create a function to expand zip files function
    Expand-ZIPFile($file, $destination) `
    { $shell = new-object `
      -com shell.application $zip = $shell.NameSpace($file) `
      foreach($item in $zip.items()) `
      { $shell.Namespace($destination).copyhere($item) } }

    # Expand the downloaded files
    Expand-ZIPFile -file $targetDirectory\AdventureWorks2016CTP3.zip `
      -destination $targetDirectory\adventureWorks2016CTP3
    Expand-ZIPFile -file $targetDirectory\adventureWorks2016CTP3\SQLServer2016CTP3Samples.zip `
      -destination $targetDirectory\adventureWorks2016CTP3

    # Copy backup files to Default SQL Backup Folder
    Copy-Item -Path $targetDirectory\AdventureWorks2016CTP3\*.bak `
    -Destination &quot;C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup&quot;

    # Restore SQL Backups for AdventureWorks and AdventrueWorksDW
    Import-Module SQLPS -DisableNameChecking cd \sql\localhost\

    Invoke-Sqlcmd -Query &quot;USE [master] RESTORE DATABASE [AdventureWorks2016CTP3] `
      FROM  DISK = N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup\AdventureWorks2016CTP3.bak' `
      WITH  FILE = 1,  MOVE N'AdventureWorks2016CTP3_Data' `
      TO N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\AdventureWorks2016CTP3_Data.mdf',  `
      MOVE N'AdventureWorks2016CTP3_Log' `
      TO N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\AdventureWorks2016CTP3_Log.ldf',  `
      MOVE N'AdventureWorks2016CTP3_mod' `
      TO N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\AdventureWorks2016CTP3_mod',  `
      NOUNLOAD,  `
      REPLACE,  `
      STATS = 5
      GO&quot; -ServerInstance `
      LOCALHOST -QueryTimeout 0

    Invoke-Sqlcmd -Query &quot;USE [master] RESTORE DATABASE [AdventureworksDW2016CTP3] `
      FROM  DISK = N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup\AdventureWorksDW2016CTP3.bak' `
      WITH  FILE = 1,  `
      MOVE N'AdventureWorksDW2014_Data' ``
      TO N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\AdventureWorksDW2016CTP3_Data.mdf',  `
      MOVE N'AdventureWorksDW2014_Log' `
      TO N'C:\Program Files\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\DATA\AdventureWorksDW2016CTP3_Log.ldf',  `
      NOUNLOAD,  `
      REPLACE,  `
      STATS = 5
      GO&quot; -ServerInstance `
      LOCALHOST -QueryTimeout 0

    # Firewall Rules
    #Enabling SQL Server Ports
    New-NetFirewallRule `
      -DisplayName “SQL Server” `
      -Direction Inbound `
      –Protocol TCP `
      –LocalPort 1433 `
      -Action allow New-NetFirewallRule `
      -DisplayName “SQL Admin Connection” `
      -Direction Inbound `
      –Protocol TCP `
      –LocalPort 1434 `
      -Action allow New-NetFirewallRule `
      -DisplayName “SQL Database Management” `
      -Direction Inbound `
      –Protocol UDP `
      –LocalPort 1434 `
      -Action allow New-NetFirewallRule `
      -DisplayName “SQL Service Broker” `
      -Direction Inbound `
      –Protocol TCP `
      –LocalPort 4022 `
      -Action allow New-NetFirewallRule `
      -DisplayName “SQL Debugger/RPC” `
      -Direction Inbound `
      –Protocol TCP `
      –LocalPort 135 `
      -Action allow

      #Enabling SQL Analysis Ports
      New-NetFirewallRule `
        -DisplayName “SQL Analysis Services” `
        -Direction Inbound `
        –Protocol TCP `
        –LocalPort 2383 `
        -Action allow

      New-NetFirewallRule `
        -DisplayName “SQL Browser” `
        -Direction Inbound `
        –Protocol TCP `
        –LocalPort 2382 `
        -Action allow

      #Enabling Misc. Applications
      New-NetFirewallRule `
        -DisplayName “HTTP” `
        -Direction Inbound `
        –Protocol TCP `
        –LocalPort 80 `
        -Action allow

      New-NetFirewallRule `
        -DisplayName “SSL” `
        -Direction Inbound `
        –Protocol TCP `
        –LocalPort 443 `
        -Action allow

      New-NetFirewallRule `
        -DisplayName “SQL Server Browse Button Service” `
        -Direction Inbound `
        –Protocol UDP `
        –LocalPort 1433 `
        -Action allow

    #Enable Windows Firewall
    Set-NetFirewallProfile `
      -DefaultInboundAction Block `
      -DefaultOutboundAction Allow `
      -NotifyOnListen True `
      -AllowUnicastResponseToMulticast True

{% endhighlight %}

By default the custom script is located in the solution but it does not have to be.  In the code example below, I actually call the script from GitHub.  Note the fileUris: link.

{% highlight json %}

resources: [{
        name: deploySql2016Ctp3,
        type: extensions,
        location: [resourceGroup().location],
        apiVersion: 2015 - 06 - 15,
        dependsOn: [
            [concat('Microsoft.Compute/virtualMachines/', parameters('Sql2016Ctp3DemoName'))]
        ],
        tags: {
            displayName: deploySql2016Ctp3
        },
        properties: {
            publisher: Microsoft.Compute,
            type: CustomScriptExtension,
            typeHandlerVersion: 1.4,
            autoUpgradeMinorVersion: true,
            settings: {
                fileUris: [https: //raw.githubusercontent.com/jgardner04/Sql2016Ctp3Demo/master/Sql2016Ctp3Demo/CustomScripts/deploySql2016Ctp3.ps1 ],
                commandToExecute: powershell.exe `
                  -ExecutionPolicy Unrestricted `
                  -File deploySql2016Ctp3.ps1 } } } ]

{% endhighlight %}

With this post we showed how we can create a virtual machine and customize it through the use of Azure Resource Manager templates.  In future posts we will explore how to expand the use of Azure Resource Manager templates to create complex services that include multiple Azure Resources and services.  Are you using Azure Resource Manager templates in your environment?  We would love to hear about it in the comments below.

If you like the content on my blog, I also blog on the US Azure and Data Analytics Partner Blogs.  I encourage you to check those out for more great resources. Also don't forget to follow me on Twitter as much of what I talk about is related to Azure.
</description>
        <pubDate>Tue, 26 Apr 2016 16:00:00 +0000</pubDate>
        <link>http://0.0.0.0:4000/azure/2016/04/26/Azure-Resource-Manager-Templates-Custom-Script-Extensions.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/azure/2016/04/26/Azure-Resource-Manager-Templates-Custom-Script-Extensions.html</guid>
        
        <category>azure</category>
        
        
        <category>Azure</category>
        
      </item>
    
      <item>
        <title>Shutdown Tagged VMs with Azure Automation</title>
        <description>&lt;span class=&quot;image featured&quot;&gt;&lt;img src=&quot;//btco.azureedge.net/gallery-1600/AdobeStock_97576601-1600.jpeg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;

In my previous post PowerShell to update the tags on resources, I added tags to the virtual machines in my subscription.  There are a host of reasons why resources may be tagged in Azure.  I have seen customers use them to identify the department or application resources belong to.  I have seen partners use tags for billing by tagging resources by customers.  The use varies but as a huge fan of automation I am going to use them to automate tasks against my virtual machines.  In this post I will use tags in conjunction with Azure Automation to shutdown virtual machines at the end of the day.

***Note: This article makes the assumption that you are familiar with the Azure portal.  I am not writing a full step-by-step article.  While I will outline all of the things that need to happen, I am not doing a “click here” walk-through.  I also am not going to cover the movement of the file from one blob to another, I will do that in a separate post.***

## The Setup
There are a lot of templates that can be used for controlling VMs in the Azure Automation gallery but for me it was not that simple.  The preferred method of security using Azure Automation is to use RBAC.  The problem, for me, is that to get Azure Automation working with RBAC you need to be able to add that resource to Azure Active Directory and then to the Azure Subscription as a Co-Administrator.  All of that works well if you own the Azure Subscription or can get a user added.  In my case, I do not and cannot have that done with the way they are configured at internally at Microsoft.

In my previous post about using [Azure Automation, my SQL Agent in the Cloud]({% post_url 2016-04-12-azure-automation-sql %}), I created an Azure Automation RunAs account when I created my Azure Automation Account.  I will use this account to perform automation actions.

## Setting up the Azure RunAs Account
In an effort to practice what I preach, I am going to link out this portion of the post in an effort not to recreate the wheel.  Checkout the documentation for how to [Authenticate Runbooks with Azure Run As Account](//docs.microsoft.com/en-us/azure/automation/).  I actually made some corrections on this documentation for the Azure team in [GitHub](//github.com/Microsoft/azure-docs) in preparation for this article and getting it to flow smoothly.

Once the New-AzureServicePrincipal.ps1 file has been run two Azure Automation Assets will have been created.  A Certificate and Connection, both will be used in the code to shut down tagged VMs.

## The Business
First create the assets necessary to automate the subscription.  The first is a schedule.  This scrip will run daily.  The second asset to create is a variable with the subscription name in it.  The subscription name is called when calling the Get-AzureRmSubscription command.  The final piece is to actually create the runbook.  Create a blank PowerShell runbook with the following code in it.

$currentTime = (Get-Date).ToUniversalTime() Write-Output &amp;amp;quot;Runbook started.&amp;amp;quot;

``` powershell
    # Establish Connection $Conn = Get-AutomationConnection `
      -Name 'AzureRunAsConnection' Add-AzureRMAccount `
      -ServicePrincipal `
      -Tenant $Conn.TenantID `
      -ApplicationId $Conn.ApplicationID `
      -CertificateThumbprint $Conn.CertificateThumbprint

    $subName = Get-AutomationVariable -Name 'Subscription' `
      Get-AzureRmSubscription -SubscriptionName $subName

    # Get a list of all tagged VMs in the Subscripiton that are running
    $resourceManagerVMList = @(Get-AzureRmResource | `
        where {$_.ResourceType -like &amp;amp;quot;Microsoft.*/virtualMachines&amp;amp;quot;} | `
        where {$_.Tags.Count -gt 0 `
          -and $_.Tags.Name `
            -contains &amp;amp;quot;AutoShutdownSchedule&amp;amp;quot;} | `
            sort Name) Write-Output &amp;amp;quot;
            Found [$($resourceManagerVMList.Count)] tagged VMs in the subscription&amp;amp;quot;

    #Shutdown any running VMs
    foreach($vm in $resourceManagerVMList) { $resourceManagerVM = Get-AzureRmVM -ResourceGroupName `
        $vm.ResourceGroupName `
          -Name $vm.Name `
          -Status foreach($vmStatus in $resourceManagerVM.Statuses) `
            { if($vmStatus.Code.CompareTo(&amp;amp;quot;PowerState/running&amp;amp;quot;) -eq 0) `
              { $resourceManagerVM | `
                Stop-AzureRmVm -Force Write-Output $vm.Name was Shutdown } } }

    Write-Output &amp;amp;quot;Runbook finished `
      (Duration: $((&amp;amp;quot;{0:hh\:mm\:ss}&amp;amp;quot; -f `
        ((Get-Date).ToUniversalTime() - $currentTime))))&amp;amp;quot;

```

This code assumes that the only VMs in the account are running in the v2 or Azure Resource Manager type.  If you are dealing with a mixed environment, additional code will need to be written to shut down those VMs.

While this is designed to shut down my VMs at the end of the day, there are some exciting new features on the horizon to help with this as well.  Some of these power scheduling features will come standard in the new [DevTest Labs](//azure.microsoft.com/en-us/services/devtest-lab/) service in Azure.

Are you using Azure Automation in your environment today?  I would love to hear about it in the comments below.  If you like the content on my blog, I also blog on the [US Azure and Data Analytics Partner Blogs](//blogs.technet.microsoft.com/msuspartner/category/data-analytics-partners/).  I encourage you to check those out for more great resources. Also don't forget to follow me on Twitter as much of what I talk about is related to Azure.
</description>
        <pubDate>Thu, 21 Apr 2016 16:00:00 +0000</pubDate>
        <link>http://0.0.0.0:4000/azure/2016/04/21/Shutdown-Tagged-VMs-with-Azure-Automation.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/azure/2016/04/21/Shutdown-Tagged-VMs-with-Azure-Automation.html</guid>
        
        <category>azure</category>
        
        <category>automation</category>
        
        
        <category>Azure</category>
        
      </item>
    
      <item>
        <title>Adding Tags to Resources in Azure</title>
        <description>&lt;span class=&quot;image featured&quot;&gt;&lt;img src=&quot;//btco.azureedge.net/gallery-1600/AdobeStock_102187112-1600.jpeg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;

I am always looking for ways to automate my Azure environment.  I use Azure as a Demo and Testing environment and do not want it running 24/7 and shutting off each virtual machine at the end of a day is time consuming.  I want to have Azure Automation do that for me.  I am working on a post to show just how to do that but the first step was to set a tag on the virtual machines that I wanted to shut down.  In this post I will walk through setting up tags for virtual machines in Azure with PowerShell. Organizing my resources by tags gives me the flexibility of applying them across resource group and allowing me to automate them across my entire subscription.  Tags can be applied in the portal but with multiple virtual machines in an environment, that is a time consuming proposition.  The smarter approach is to apply them systematically through PowerShell.  In this short post I will share the script I used to apply tags to my virtual machines.

## The Business

In the script below I set the tags on the entire DemoAndTesting before applying it to the virtual machines. This step is not necessary to apply the tag only to virtual machines.  I also limit the tags to the virtual machines in that same resource group in the code below.

``` powershell

  Login-AzureRmAccount $rmGroupName = &quot;DemoAndTesting&quot; `
    Set-AzureRmResourceGroup -Name $rmGroupName `
    -Tag @( @{ Name=&quot;vmType&quot;; Value=&quot;test&quot;}) $tags = `
      (Get-AzureRmResourceGroup -Name $rmGroupName).Tags `
      Get-AzureRmResource |`
        where {$_.ResourceType -eq &quot;Microsoft.Compute/virtualMachines&quot; -and $_.ResourceGRoupName -eq $rmGroupName} | `
        ForEach-Object {Set-AzureRmResource -Tag $tags -ResourceId $_.ResourceId -force}

```

The code to just apply the tags all virtual machines in a subscription it would look like the following.

``` powershell
    Login-AzureRmAccount Get-AzureRmResource |`
      where {$_.ResourceType -eq &quot;Microsoft.Compute/virtualMachines&quot;} | `
      ForEach-Object {Set-AzureRmResource `
        -Tag @( @{ Name=&quot;vmType&quot;; Value=&quot;test&quot;}) `
        -ResourceId $_.ResourceId `
        -force}
        
```

As a database administrator at heart I hated to create a cursor (ForEach-Object) to do this but trying a set based pipe didn't work.  I would love to hear from you if you are doing this in a different way.  How are you using tags in your Azure environment?  Let us know in the comments below.
</description>
        <pubDate>Tue, 12 Apr 2016 16:00:00 +0000</pubDate>
        <link>http://0.0.0.0:4000/azure/2016/04/12/Adding-Tags-to-Resources-in-Azure.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/azure/2016/04/12/Adding-Tags-to-Resources-in-Azure.html</guid>
        
        <category>azure</category>
        
        
        <category>Azure</category>
        
      </item>
    
      <item>
        <title>Azure Automation, My SQL Agent in the Cloud</title>
        <description>&lt;span class=&quot;image featured&quot;&gt;&lt;img src=&quot;//btco.azureedge.net/gallery-1600/death_to_stock_photography_weekend_work-2-of-10-1600.jpg&quot; alt=&quot;&quot;&gt;&lt;/span&gt;


My focus for the past 18 moths at Microsoft has been on Azure but that does not mean I left my love for SQL behind.  In fact, has become an asset.  In the course of regular operations I have built out a workflow to import call statistics and reporting data from our community activities into Azure SQL for reporting in Power BI.  In that process I needed the ability to run a stored procedure on schedule to normalize some data.  Without a SQL Agent in Azure SQL, I use Azure Automation to get this done.  In this article I will walk through the application workflow and how I set up Azure Automation to be my SQL Agent in the cloud.

## Workflow &amp; Setup
Before we get started, a bit of context on the data workflow.  The raw data is delivered via email in a password protected Excel file.  I extract the relevant data into a .CSV file and upload it to Azure Blob Storage.  I have created an Azure Data Factory pipeline to check the storage location and pipe the data into a staging table in Azure SQL Database.  At this point, I need to normalize the data into my database and archive the file in the event that I want to access the raw data later.

This article makes the assumption that you are familiar with the Azure portal.  I am not writing a full step-by-step article.  While I will outline all of the things that need to happen, I am not doing a &quot;click here&quot; walk-through.  I also am not going to cover the movement of the file from one blob to another, I will do that in a separate post.

## Automation Account
As the name of the article suggests, we are going to start with an Automation Account.  Create an account with the requisite name, subscription, resource group and location.  I choose to create an Azure Run As account but determine if this is right for your security needs.  Once open, the default Automation account looks like the image below.

![Automation Account](//btco.azureedge.net/gallery/automationaccount.png)

## The Basics
Before we get started with the specific workflow, it is important to understand the structure of an Automation account.  Runbooks are where we will write the actions that we want to perform, assets are resources that we can call into the Runbook and there are various types, finally jobs are the actual execution of the Runbook.  It is also important to note that you can nest these Runbooks for complex tasks.

I cover the separation of assets from the code to highlight the fact that a Runbook can be created that can execute against many different environments.  In this case we can create a single Runbook that can execute across multiple SQL Servers by creating a combination of assets and jobs.  An advanced example may be that you have some index maintenance you perform and want to create one job that connects to all of your databases to execute.

## Creating Assets
Before creating the Runbook, we will create some assets to call in it.  The first is a credential.  This is the credential of the SQL Server that you will connect to.  The second asset I would create is a schedule.  I run my script daily so I create a schedule to reflect that but there is an hourly option as well.

## The Runbook
With my assets created, I create a PowerShell Workflow Runbook with the following code.

```powershell
    workflow Execute-SQL { param( [parameter(Manditory=$true)] [string] $SqlServer,&amp;amp;lt;/code&amp;amp;gt;

    [parameter(Manditory=$false)] [int] $SqlServerPort = 1433,
    [parameter(Manditory=$true)] [string] $Database,
    [parameter(Manditory=$true)] [PSCredential] $SqlCredential )

    $SqlUsername = $SqlCredential.UserName $SqlPassword = $SqlCredential.GetNetworkCredential().Password

    inlinescript{ $Connection = New-Object System.Data.SqlClient.SqlConnection(&amp;amp;quot;Server=tcp:$using:SqlServer,$using:SqlServerPort;Database=$using:Database;User ID=$using:SqlUsername;Password=$using:SqlPass;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;&amp;amp;quot;) $Connection.Open() $Cmd=New-Object System.Data.SqlClient.SqlCommand(&amp;amp;quot;EXECUTE usp_MyStoredProcedure&amp;amp;quot;, $Connection) $Cmd.CommandTimeout=120 $DataSet=New-Object System.Data.DataSet $DataAdapter=New-Object System.Data.SqlClient.SqlDataAdapter($Cmd) [void]$DataAdapter.fill($DataSet) $Connection.Close() } }
```
&lt;br /&gt;
While you can create the workflow yourself. You do not necessarily need to create it from scratch.  There is a gallery with hundreds of community driven templates to get you started.  To create a Runbook from the gallery, simply hit the gallery button shown below.

![Runbooks](//btco.azureedge.net/gallery/runbooks.png)

## Schedule Execution
The final step to making Azure Automation your SQL Agent in the cloud is to schedule the Runbook.  From the Runbook panel, shown in the image below, select schedule to associate the one created when setting up our assets.   Configure the parameters that are defined in the Runbook (SQLServer, Port, Database, SqlCredential).

![Runbooks](//btco.azureedge.net/gallery/executesql.png)

Note that the SqlCredential is the name of the asset created earlier.  The rest of the parameters are going to be the actual names unless they have been defined as assets.

## Wrap up
There are a ton of advanced functions in Azure Automation that didn't get covered but this should be the basics to help you get started.  How are you using Azure Automation?  We would love to hear from you in the comments below.
</description>
        <pubDate>Tue, 12 Apr 2016 16:00:00 +0000</pubDate>
        <link>http://0.0.0.0:4000/azure/2016/04/12/azure-automation-sql.html</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/azure/2016/04/12/azure-automation-sql.html</guid>
        
        <category>sql</category>
        
        <category>azure</category>
        
        <category>automation</category>
        
        
        <category>Azure</category>
        
      </item>
    
  </channel>
</rss>
